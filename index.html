<!DOCTYPE html>
<html dir="ltr" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Google Cloud Certified Professional Cloud Architect</title>
    <meta name="author" content="Moriaki Kogure" />
    <link rel="stylesheet" href="./asset/style.css" />
    <link rel="icon" href="favicon.ico" />
  </head>

  <body>
    <h1>Google Cloud Certified Professional Cloud Architect</h1>

    <h4>資格概要</h4>
    <blockquote>
      <a href="https://cloud.google.com/learn/certification/cloud-architect?hl=ja" target="_blank"
        >Google Cloud Certified Professional Cloud Architect</a
      >
    </blockquote>

    <h4>学習進捗</h4>
    <div>
      <span id="practice-progress"></span>
      <button id="reset-btn">進捗リセット</button>
    </div>

    <h4>
      <span>コンテンツ</span>
      <div class="toggle-box-wrapper">
        <input type="checkbox" class="toggle-box" id="toggle-show-complete-content" />
        <label for="toggle-show-complete-content" class="toggle-box-label">学習済みコンテンツを表示</label>
      </div>
    </h4>
    <div id="page-tree"></div>

    <h2>AI/ML</h2>

    <h3>Vertex AI</h3>
    <p>
      MLモデルやAIアプリケーションの<m-b>学習</m-b>と<m-b>推論</m-b>を行ったり、
      <m-b>LLM</m-b>のカスタマイズを行ったりできる、機械学習プラットフォーム。<br />
      次のMLワークフローに対応した機能が提供される。
    </p>
    <ol>
      <li><m-b>データの準備</m-b></li>
      <li><m-b>モデルのトレーニング</m-b></li>
      <li><m-b>モデル評価とインテグレーション</m-b></li>
      <li><m-b>モデルのデプロイ</m-b></li>
      <li><m-b>モデルのモニタリング</m-b></li>
    </ol>

    <h3>Vertex AI - データの準備</h3>
    <p>
      データセットの抽出や整形を行い、<m-b>EDA</m-b>を実行してデータスキーマの確認と特徴量の抽出を行い、
      データを<m-b>訓練データ</m-b>と<m-b>テストデータ</m-b>に分割する。データの探索や可視化には<m-b
        >Vertex AI Workbenchノートブック</m-b
      >を使用する。 これは<m-b>Cloud Storage</m-b>や<m-b>BigQuery</m-b>と統合されていて、高速にデータアクセスが実現できる。
      大規模なデータの場合、<m-b>Dataproc Serverless Spark</m-b>を使用し、サーバーレスにワークロードを実行する。
    </p>

    <h3>Vertex AI - モデルのトレーニング</h3>
    <p>以下のようなトレーニング方法を選択できる。</p>
    <ul>
      <li><m-b>AutoML</m-b>: コードを記述せずにモデルをトレーニングする。</li>
      <li>
        カスタムトレーニング:
        <m-b>PyTorch</m-b>、<m-b>TensorFlow</m-b>、<m-b>scikit-learn</m-b>などを用いて、 独自のトレーニングコードを開発する。
      </li>
      <li><m-b>Vertex AI Vizier</m-b>: MLモデルのハイパーパラメータをチューニングする。</li>
      <li><m-b>Vertex AI Experiments</m-b>: 様々な手法でモデルをトレーニングし、比較できる。</li>
    </ul>

    <h3>Vertex AI - モデル評価とインテグレーション</h3>
    <p>
      <m-b>Vertex AI Pipelines</m-b>を用いて、トレーニングやモデル評価を行うパイプラインを構築し、 基準を満たすモデルを<m-b
        >Vertex AI Model Registry</m-b
      >に登録することができる。
    </p>

    <h3>Vertex AI - モデルのデプロイ</h3>
    <p>
      ユースケースに応じてVMやコンテナなどのランタイム環境を用意し、推論を実行する。<br />
      特徴量を一元管理するソリューションとして、<m-b>Vertex AI Feature Store</m-b>がある。
      また、各特徴が推論にどのような影響を与えるか把握し、誤ったラベル・トレーニングデータを見つけるソリューションとして、
      <m-b>Vertex Explainable AI</m-b>がある。
    </p>

    <h3>Vertex AI - モデルのモニタリング</h3>
    <p><m-b>Vertex AI Model Monitoring</m-b>を使用し、デプロイされたモデルのパフォーマンスをモニタリングできる。</p>

    <h3>Vertex AI - 提供されるAIモデル</h3>
    <p>
      <m-b>Model Garden</m-b>を使用すると、150を超えるLLMなどのAIモデルを利用することはできる。
      Googleが開発したモデル以外にも、Meta社の<m-b>Llama2</m-b>やAnthropic社の<m-b>Claude</m-b>も利用できる。
    </p>

    <h3>その他のソリューション</h3>
    <table>
      <thead>
        <tr>
          <th>ソリューション</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>Speech-to-Text</m-b></td>
          <td>
            音声データをテキストデータに変換する。<br />
            <m-b>125</m-b>の言語に対応した<m-b>Chirp</m-b>という基盤モデルを利用する。
          </td>
        </tr>
        <tr>
          <td><m-b>Text-to-Speech</m-b></td>
          <td>テキストデータを音声データに変換する。</td>
        </tr>
        <tr>
          <td><m-b>Vision AI</m-b></td>
          <td>画像を分析し、分類や検出などのタスクを行う。</td>
        </tr>
        <tr>
          <td><m-b>Natural Language AI</m-b></td>
          <td>自然言語の分析を行い、感情分析やエンティティ分析、コンテンツ分類などのタスクを行う。</td>
        </tr>
        <tr>
          <td><m-b>Recommendations AI</m-b></td>
          <td>レコメンドエンジンの機能を提供する。</td>
        </tr>
        <tr>
          <td><m-b>Translation AI</m-b></td>
          <td>ドキュメント、Webサイト、音声ファイル、動画などの翻訳タスクを行う。</td>
        </tr>
      </tbody>
    </table>

    <h2>コンピューティング</h2>

    <h3>Compute Engine - マシンタイプ</h3>
    <p>
      <m-b>vCPU</m-b>と<m-b>メモリサイズ</m-b>の設定の組み合わせをマシンタイプと呼ぶ。
      マシンタイプには、<m-b>事前定義のマシンタイプ</m-b>と<m-b>カスタムマシンタイプ</m-b>がある。
      前者はインスタンスの用途でグループ化され、そのグループは<m-b>マシンファミリー</m-b>と呼ばれ、以下のものが存在する。
    </p>
    <table>
      <thead>
        <tr>
          <th>名前</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>汎用</m-b></td>
          <td>コスパがよく、様々な用途で使用する。</td>
        </tr>
        <tr>
          <td><m-b>コンピューティング最適化</m-b></td>
          <td>高負荷や高速な演算処理ができる。</td>
        </tr>
        <tr>
          <td><m-b>メモリ最適化</m-b></td>
          <td>大容量のデータを処理できる。</td>
        </tr>
        <tr>
          <td><m-b>アクセラレータ最適化</m-b></td>
          <td>機械学習など、GPUが必要な場合に使用する。</td>
        </tr>
      </tbody>
    </table>

    <h3>Compute Engine - ブロックストレージ</h3>
    <table>
      <thead>
        <tr>
          <th>ストレージ</th>
          <th>冗長性</th>
          <th class="wrappable">I/O性能</th>
          <th class="wrappable">ハードウェアの選択</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>ゾーン永続ディスク</m-b></td>
          <td>単一ゾーン</td>
          <td>中</td>
          <td>HDD、SSD</td>
        </tr>
        <tr>
          <td><m-b>リージョン永続ディスク</m-b></td>
          <td>リージョン内の2つのゾーン</td>
          <td class="wrappable">やや低<br />※通信分のオーバーヘッドが生じる</td>
          <td>HDD、SSD</td>
        </tr>
        <tr>
          <td><m-b>ローカルSSD</m-b></td>
          <td class="wrappable">なし<br />(インスタンスが停止するとデータは削除)</td>
          <td>高</td>
          <td>SSD</td>
        </tr>
      </tbody>
    </table>
    <p>
      ブートディスクには、<m-b>ゾーン永続化ディスク</m-b>のみ使用できる。<br />
      ブートディスク以外の追加のストレージを<m-b>ストレージオプション</m-b>と呼ぶ。<br />
      最新世代のネットワークブロックストレージとして、<m-b>Google Cloud Hyperdisk</m-b>がある。
      パフォーマンスと容量の動的なスケーリングが可能で、
      <m-b>NVMe</m-b>または<m-b>SCSI</m-b>でVMのディスクとしてマウントができる。
    </p>

    <h3>Compute Engine - バックアップ</h3>
    <h4><m-b>スナップショット</m-b></h4>
    <p>
      初回はフルバックアップで、それ以降は増分バックアップとして永続ディスクのバックアップを取得する。
      自動・定期的に取得することも可能。
    </p>
    <h4><m-b>マシンイメージ</m-b></h4>
    <p>
      ストレージを含むインスタンス全体から、ストレージのデータ、マシンタイプやサービスアカウントといったメタデータも含め、
      あらゆる情報のバックアップを取得できる。
      これにより、既存のインスタンスと全く同じ構成・データのインスタンスを作成することができる。
    </p>

    <h3>Compute Engine - サービスアカウント</h3>
    <p>
      Compute Engineから他のGoogle
      Cloudリソースにアクセスする場合、<m-b>インスタンス</m-b>に設定したサービスアカウントの権限が適用される。
      デフォルトでは<m-b>Compute Engine default service account</m-b>というサービスアカウントが適用されるが、
      <m-b>編集者</m-b>ロールが付与されていて、そのまま使うことは推奨されない。
    </p>

    <h3>Compute Engine - リモート接続</h3>
    <p>
      インスタンスにリモートで接続する場合、<m-b>SSH</m-b>や<m-b>RDP</m-b>といったプロトコルを使用する。<br />
      Linux OSインスタンスの場合、<m-b>OS Login</m-b>と呼ばれる、IAMで認証を管理する機能もある。
      これにより、<m-b>SSHユーザ</m-b>とGoogleアカウントを紐づけて管理することができ、
      <m-b>ログイン</m-b>可否や<m-b>sudo</m-b>可否を設定することもできる。<br />
      また、インスタンスの起動などで問題が生じ、リモート接続ができない場合に、
      <m-b>シリアルコンソール</m-b>で接続し、トラブルシューティングを行うことも可能。
    </p>

    <h3>Compute Engine - マネージドインスタンスグループ</h3>
    <p>
      マネージドインスタンスグループ(MIG)とは、可用性やスケーラビリティを実現するために、
      インスタンスをグループ化する機能である。
      <m-b>インスタンステンプレート</m-b>と呼ばれるひな型を持ちいてインスタンスを作成する。 主に次の機能がある。<br />
      可用性の要件に応じて、各インスタンスを<m-b>ゾーン</m-b>内、 または<m-b>リージョン</m-b>内に配置することが可能。
    </p>
    <table>
      <thead>
        <tr>
          <th>機能</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>自動修復</m-b></td>
          <td>インスタンスに不具合がある場合に、自動的にインスタンスを再作成する。</td>
        </tr>
        <tr>
          <td><m-b>負荷分散</m-b></td>
          <td><m-b>Cloud Load Balancing</m-b>などと組み合わせ、ワークロードを分散する。</td>
        </tr>
        <tr>
          <td><m-b>ヘルスチェック</m-b></td>
          <td>インスタンスの正常性を確認する。</td>
        </tr>
        <tr>
          <td><m-b>自動スケーリング</m-b></td>
          <td>負荷に応じてインスタンス数を変える。</td>
        </tr>
        <tr>
          <td><m-b>ローリングアップデート</m-b></td>
          <td>インスタンスを順番に更新することで、アプリケーション全体を停止せずにアップデートする。</td>
        </tr>
      </tbody>
    </table>

    <h3>Compute Engine - MIGで指定可能なパラメータ</h3>
    <ul>
      <li><m-b>インスタンス数の最大数</m-b></li>
      <li><m-b>インスタンス数の最小数</m-b></li>
      <li><m-b>目標使用率の指標</m-b></li>
      <li><m-b>クールダウン期間</m-b></li>
      <li><m-b>最大サージ</m-b>: ローリングアップデート中に最大数を超えて作成できるインスタンス数</li>
      <li><m-b>オフライン上限</m-b>: ローリングアップデート中に利用できなくなるインスタンス数の上限</li>
    </ul>

    <h3>App Engine - スタンダード環境とフレキシブル環境の違い</h3>
    <table>
      <thead>
        <tr>
          <th>項目</th>
          <th>スタンダード環境</th>
          <th>フレキシブル環境</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>アプリケーションの実行</td>
          <td class="wrappable">ディスクへの<m-b>書き込み</m-b>ができないなど、制限あり</td>
          <td class="wrappable">
            <ul>
              <li>制限が少ない</li>
              <li><m-b>Compute Engineインスタンス</m-b>上のDockerコンテナ内で実行される</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>自動スケーリングの性能</td>
          <td class="wrappable">
            <ul>
              <li>急激なトラフィックの増大に耐えられる</li>
              <li>トラフィックが0の場合に、<m-b>ゼロスケール</m-b>が可能</li>
            </ul>
          </td>
          <td class="wrappable">時間がかかる</td>
        </tr>
        <tr>
          <td>料金</td>
          <td class="wrappable">
            <ul>
              <li>App Engineインスタンスの<m-b>起動時間</m-b>に対して課金</li>
              <li>無料枠が<m-b>ある</m-b></li>
            </ul>
          </td>
          <td class="wrappable">
            <ul>
              <li><m-b>vCPU</m-b>、<m-b>メモリ</m-b>、<m-b>永続ディスクの使用量</m-b>に対して課金</li>
              <li>無料枠が<m-b>ない</m-b></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>ユースケース</td>
          <td class="wrappable">
            <ul>
              <li>無料または低コストでアプリケーションを運用したい</li>
              <li>トラフィックが安定<m-b>していない</m-b></li>
            </ul>
          </td>
          <td class="wrappable">
            <ul>
              <li>制限の少ない環境で実行したい</li>
              <li>トラフィックが安定<m-b>している</m-b></li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>

    <h3>App Engine - トラフィックの移行</h3>
    <p>
      移行先のインスタンスの準備が整い次第、段階的にトラフィックを移行する処理方針を、<m-b>ウォームアップリクエスト</m-b>と呼ぶ。
      これは、<m-b>スタンダード</m-b>環境のみ対応していて、<m-b>フレキシブル</m-b>環境では使用できない。
    </p>

    <h3>Cloud Batch</h3>
    <p>
      Google Cloud上で大量のバッチジョブを効率的に実行するためのサービス。
      コンピューティングリソースの<m-b>自動プロビジョニング</m-b>や、ジョブの<m-b>キュー管理</m-b>を行い、
      ジョブの依存関係に基づいて<m-b>スケジューリング</m-b>を実行する。
      HPCやデータ変換、機械学習のタスクなどを実行するのに適したソリューションと言える。<br />
      1つの処理単位を<m-b>タスク</m-b>と呼び、その集合である一連の処理を<m-b>ジョブ</m-b>と呼ぶ。<br />
      <m-b>リザーブドインスタンス</m-b>や<m-b>Spot VM</m-b>を活用することで、コストを抑えることができる。
    </p>

    <h3>Cloud Batch - アーキテクチャ</h3>
    <ul>
      <li><m-b>ジョブマネージャ</m-b>: 各タスクのキューイングや依存関係の管理、リソースの割り当てを行う。</li>
      <li><m-b>Compute Engine インスタンス</m-b>: 自動的にプロビジョニングされ、ジョブを実行するランタイムを提供する。</li>
      <li><m-b>スケジューラ</m-b>: ジョブのスケジュールを管理し、指定された順序・タイミングでタスクを実行する。</li>
      <li>
        <m-b>ストレージ</m-b>: 入力データや出力データを保持するため、<m-b>Cloud Storage</m-b
        >や<m-b>BigQuery</m-b>と統合されている。
      </li>
    </ul>

    <h2>コンテナ</h2>

    <h3>GKE - 運用モード</h3>
    <table>
      <thead>
        <tr>
          <th>運用モード</th>
          <th>メリット</th>
          <th>デメリット</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>Autopilotモード</m-b></td>
          <td class="wrappable">クラスタ運用をGKEに任せて、アプリケーション構築に集中できる</td>
          <td class="wrappable">いくつか制約がある</td>
        </tr>
        <tr>
          <td><m-b>Standardモード</m-b></td>
          <td class="wrappable">クラスタを柔軟に設計・運用できる</td>
          <td class="wrappable">運用が煩雑</td>
        </tr>
      </tbody>
    </table>

    <h3>GKE - 自動スケーリングの種類</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>スケーリングの対象</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>水平ポッド自動スケーリング</m-b></td>
          <td>ポッド</td>
          <td>
            ポッドの数を増減する機能<br />
            Webアプリケーションなどで使用
          </td>
        </tr>
        <tr>
          <td><m-b>垂直ポッド自動スケーリング</m-b></td>
          <td>ポッド</td>
          <td>
            ポッドに割り当てるリソースの推奨値を算出し、ポッドのスペックを更新する機能<br />
            データベースなどで使用
          </td>
        </tr>
        <tr>
          <td><m-b>クラスタオートスケーラー</m-b></td>
          <td>ノード</td>
          <td>ノードプールのノード数を増減する機能(水平方向)</td>
        </tr>
        <tr>
          <td><m-b>ノード自動プロビジョニング</m-b></td>
          <td>ノード</td>
          <td>リソースの需要に応じてノードプールの作成・削除を行う機能(垂直方向)</td>
        </tr>
      </tbody>
    </table>

    <h3>GKE - 限定公開クラスタ</h3>
    <p>
      <m-b>外部IPアドレス</m-b>が付与されない、インターネットから隔離されたクラスタ。
      <m-b>VPCネットワーク</m-b>内でのみアクセスが可能であり、セキュリティを強化することができる。
    </p>

    <h3>Cloud Run - 実行方法</h3>
    <ul>
      <li><m-b>Cloud Run サービス</m-b>: Webリクエスト、イベント、関数に応答する</li>
      <li><m-b>Cloud Run ジョブ</m-b>: バッチなど作業を実行する</li>
    </ul>

    <h3>Cloud Run - 自動スケーリング関連のパラメータ</h3>
    <table>
      <thead>
        <tr>
          <th>パラメータ</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>コンテナ最大数</m-b></td>
          <td>スケーリングの上限値。コスト増大の抑制などに使用。</td>
        </tr>
        <tr>
          <td><m-b>コンテナ際小数</m-b></td>
          <td>スケーリングの下限値。<m-b>コールドスタート</m-b>対策で使用。</td>
        </tr>
        <tr>
          <td><m-b>コンテナあたり最大同時リクエスト数</m-b></td>
          <td>1つのコンテナで同時に処理するリクエスト数。</td>
        </tr>
      </tbody>
    </table>

    <h3>Cloud Run - GPU</h3>
    <p>
      AI推論や動画処理としてCloud Runを使用するために、GPUを割り当てることができる。
      インスタンス1つに対して、<m-b>1つ</m-b>の<m-b>NVIDIA L4 GPU </m-b>を使用できる。
      インスタンスメモリとは別に、<m-b>24GB</m-b>のGPUメモリが割り当てられる。<br />
      GPUを利用するには、登録ページから対象のCloud Runプロジェクトを<m-b>許可リスト</m-b>に追加する必要がある。
      GPUをサポートするリージョンは、<m-b>us-central1(アイオワ)</m-b>のみである点にも注意が必要。
    </p>

    <h3>Cloud Run for Anthos</h3>
    <p>
      Anthosとは、<m-b>ハイブリッド</m-b>環境や<m-b>マルチクラウド</m-b>環境において、
      コンテナアプリケーションを一元管理するプラットフォームである。
      クラウド/オンプレ上の<m-b>Kubernetes</m-b>クラスタを基盤として、アプリケーションを実行する。<br />
      Cloud Run for Anthosとは、複雑なインフラを持つAnthos環境を、 コンテナのサーバーレス環境として提供するプロダクトである。
      Cloud Runの実行場所を、オンプレやGoogle Cloud内のKubernetesクラスタに指定できる。
    </p>

    <h3>Cloud Build</h3>
    <p>
      Google Cloud上で<m-b>CI/CDパイプライン</m-b>を実現するためのフルマネージドなサービス。
      様々なリポジトリやクラウドストレージからソースをインポートし、定義されたビルドタスクを実行し、
      コンテナやアーカイブなどのアーティファクトを生成する。
      ビルド構成を定義する場合、プロジェクトのルートに<m-b>cloudbuild.yaml</m-b>または<m-b>cloudbuild.json</m-b>を配置し、そこにそれぞれのフォーマットで構成を記述する。
    </p>

    <h3>Cloud Build - ビルドの開始</h3>
    <p>
      <m-b>Google Cloud CLI</m-b>や<m-b>Cloud Build API</m-b>を使用して、手動でビルドを開始することができる。
      また、<m-b>ビルドトリガー</m-b>を使用することで、コードの変更を検知してビルドを開始する、CI/CDワークフローの自動化も実現できる。
      これは、GithubやBitbucketなどからトリガーする<m-b>リポジトリイベントトリガー</m-b>や、<m-b>Pub/Subトリガー</m-b>、<m-b>Webhookトリガー</m-b>などがある。
    </p>

    <h3>Cloud Build - 実行環境</h3>
    <p>
      Cloud Buildでビルドを開始すると、デフォルトでインターネットにアクセス可能なランタイム環境が構築される。
      各ビルドは独自の<m-b>ワーカー</m-b>上で実行され、他のワークロードから分離される。<br />
      また、プライベートネットワーク内にビルド環境を実行する方法として、<m-b>プライベートプール</m-b>がある。
    </p>

    <h3>Cloud Code</h3>
    <p>
      <m-b>GKE</m-b>や<m-b>Cloud Run</m-b
      >などのGoogleサービスを、直接操作できるようにする一般的な<m-b>IDE</m-b>向けのプラグイン。
      <m-b>Gemini Code Assist</m-b>と統合されていて、AIアシスト機能の恩恵を得ることもできる。
      その他、クラウド上で稼働するアプリケーションをデバッグする<m-b>リモートデバッグ</m-b>機能や、
      Kubernetesのマニフェストファイルの記述をサポートする<m-b>YAMLオーサリングサポート</m-b>機能などがある。
    </p>

    <h3>Cloud Deploy</h3>
    <p>
      <m-b>GKE</m-b>や<m-b>Cloud Run</m-b>、<m-b>Anthos</m-b>への<m-b>CD</m-b>を簡単に実現するためのフルマネージドなサービス。
      リリースを定義し、テスト環境、ステージ環境、本番環境とリリースを進めることができる。
      デプロイの操作は、<m-b>Webコンソール</m-b>や<m-b>CLI</m-b>、<m-b>API</m-b>を介して行うことができる。
      その他、<m-b>IAM</m-b>による環境ごとの権限制御や、<m-b>Cloud Logging</m-b>によるイベント監視、
      <m-b>Cloud Audit Logs</m-b>によるトレーサビリティの実現なども可能である。
    </p>

    <h2>データ分析</h2>

    <h3>BigQuery</h3>
    <p>
      <m-b>サーバーレス</m-b>で<m-b>フルマネージド</m-b>なデータウェアハウスのサービス。
      データを蓄積する<m-b>ストレージ</m-b>機能と、クエリを実行する<m-b>コンピューティング</m-b>機能に分かれている。
      各リソースは無制限にスケーリングが可能であり、<m-b>ペタバイト</m-b>を超えるデータに対しても、短時間でSQLクエリを完了できる。<br />
      他のRDBMSと異なり、データを<m-b>列</m-b>単位で格納するため、大量データの集計処理などに優れる。
      一方、<m-b>行</m-b>単位の処理を苦手とする。
    </p>

    <h3>BigQuery - コンピューティング</h3>
    <p>
      <m-b>ジョブ</m-b>と呼ばれる単位で、クエリなどの処理を<m-b>サーバーレス</m-b>に実行する。
      <m-b>Dremel</m-b>と呼ばれる分散システムがベースとなっていて、大規模なデータの<m-b>リアルタイム</m-b>処理が可能。<br />
      課金モデルとしては、<m-b>オンデマンドモデル</m-b>と<m-b>定額課金モデル</m-b>がある。
    </p>

    <h3>BigQuery - ストレージ構造</h3>
    <p>
      BigQueryで管理されるデータは、<m-b>データセット</m-b>と呼ばれる論理コンテナで管理される。
      これを作成するとき、<m-b>リージョン</m-b>を指定する必要がある。 以下のオブジェクトを持つことができる。
    </p>
    <ul>
      <li><m-b>テーブル</m-b></li>
      <li><m-b>ビュー</m-b></li>
      <li><m-b>マテリアライズドビュー</m-b></li>
      <li>
        <m-b>外部テーブル</m-b>: BigQuery外のデータにアクセスするテーブル。 <m-b>GCS</m-b>、<m-b>Google Drive</m-b
        >、<m-b>Bigtable</m-b>、<m-b>Google Sheets</m-b>などにアクセスする。
      </li>
      <li>
        <m-b>ルーチン</m-b>:
        BiqQuery内で実装するロジック。<m-b>ストアドプロシージャ</m-b>や<m-b>ユーザ定義関数</m-b>が含まれる。
      </li>
      <li><m-b>パラメータ化クエリ</m-b>: パラメータを渡すことで、動的にクエリを実行する機能。</li>
      <li><m-b>モデル</m-b>: <m-b>BigQuery ML</m-b>によって作成された機械学習モデル。</li>
    </ul>

    <h3>BigQuery - テーブルの種別</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>ネイティブテーブル</m-b></td>
          <td>BigQuery内部のストレージで管理されるテーブル</td>
        </tr>
        <tr>
          <td><m-b>外部テーブル</m-b></td>
          <td>BigQuery外部のストレージで管理されるテーブル</td>
        </tr>
        <tr>
          <td><m-b>ビュー</m-b></td>
          <td>SQLクエリで定義される仮想テーブル</td>
        </tr>
      </tbody>
    </table>

    <h3>BigQuery - 処理効率を向上するテーブル設計</h3>
    <p>
      BigQueryでは、処理する<m-b>データ量</m-b>に応じて課金されるため、効率的なデータ読み込みが重要であり、
      <m-b>パーティショニング</m-b>と<m-b>クラスタリング</m-b>の機能を活用することができる。<br />
      <m-b>パーティショニング</m-b>は、キーの値に応じてテーブルを分割する機能で、
      分割したテーブルを<m-b>パーティション分割テーブル</m-b>と呼ぶ。
      各パーティションには<m-b>有効期限</m-b>を設定し、自動で<m-b>削除</m-b>することができる。<br />
      <m-b>クラスタリング</m-b>は、テーブル内のデータを並び替える機能で、
      適用されたテーブルを<m-b>クラスタ化テーブル</m-b>と呼ぶ。
      適用する際、任意の<m-b>列</m-b>を<m-b>クラスタ化列</m-b>として指定し、
      クエリの<m-b>WHERE句</m-b>に指定することで処理するデータ量を節約することができる。
    </p>

    <h3>BigQuery - セキュリティとデータ保護</h3>
    <p>
      BigQueryは、データ暗号化のために<m-b>自動暗号化</m-b>を提供し、<m-b>IAMポリシー</m-b>を通じてきめ細かなアクセス制御が可能。
      また、<m-b>VPC Service Controls</m-b>を利用してネットワーク境界での保護を強化することもできる。
    </p>

    <h3>Dataflow</h3>
    <p>
      <m-b>サーバーレス</m-b>かつ<m-b>フルマネージド</m-b>な<m-b>データ処理</m-b>のプロダクト。
      主に<m-b>ETL</m-b>として使用される。 処理の内容は、<m-b>Apache Beam</m-b
      >というオープンソースのデータ処理フレームワークを用いて記述する。
    </p>

    <h3>Dataproc</h3>
    <p>
      <m-b>Apache Spark / Hadoop</m-b>クラスタを実行するための、フルマネージドなプロダクト。
      デフォルトのストレージ領域として、<m-b>Compute Engine</m-b>の<m-b>永続ディスク</m-b>が使用されるが、
      これは<m-b>Hadoop分散ファイルシステム</m-b>と呼ばれる。 ここに保存されるデータはクラスタの削除と共に消えてしまうため、
      <m-b>Cloud Storage</m-b>を利用してデータの永続化が推奨される。
    </p>

    <h3>Dataplex</h3>
    <p>
      分散されたデータの統合、管理を自動化し、<m-b>データガバナンス</m-b>を実現するためのフルマネージドなサービス。
      以下のような機能を提供する。
    </p>
    <ul>
      <li>組織内の複数のプロジェクトに分散されたデータを統合し、<m-b>データメッシュ</m-b>を構築する</li>
      <li>IAMを用いて、<m-b>アクセス権限</m-b>を一元管理する</li>
      <li><m-b>メタデータ</m-b>を付与することでデータをカタログ化する</li>
      <li>データの<m-b>ライフサイクル</m-b>を定義し、データの作成や削除を自動化する</li>
    </ul>

    <h2>データベース</h2>

    <h3>Cloud SQL</h3>
    <p>
      フルマネージドなRDBサービスである。
      <m-b>Compute Engine</m-b>のインスタンスをベースに動作する。 ストレージの上限は<m-b>64TB</m-b>に設定されている。
    </p>

    <h3>Cloud SQL - 選択可能なDBMS</h3>
    <ul>
      <li><m-b>PostgreSQL</m-b></li>
      <li><m-b>MySQL</m-b></li>
      <li><m-b>SQL Server</m-b></li>
    </ul>

    <h3>Cloud SQL - HA構成</h3>
    <p>
      Cloud SQLでHA構成を有効にすると、
      <m-b>リージョン</m-b>内に<m-b>プライマリゾーン</m-b>と<m-b>セカンダリゾーン</m-b>が作成される。
      それぞれには、<m-b>プライマリインスタンス</m-b>と<m-b>スタンバイインスタンス</m-b>が配置される。
      前者に障害が発生した場合、後者に<m-b>フェイルオーバー</m-b>が実施される。
      このとき、クライアントがデータベースに接続するIPアドレスは変更<m-b>されない</m-b>。
    </p>

    <h3>Cloud SQL - レプリケーション</h3>
    <p>
      Cloud SQLのレプリケーションは、<m-b>リードレプリカ</m-b>のインスタンスのコピーを作成する機能である。
      <m-b>クロスリージョンレプリカ</m-b>として、インスタンスを別リージョンに作成することもできる。
    </p>

    <h3>Cloud SQL - バックアップ</h3>
    <ul>
      <li>
        <m-b>オンデマンドレプリカ</m-b>: ユーザの任意のタイミングで作成できるバックアップ。
        作成したバックアップは明示的に削除しないと残り、コストが発生するため注意が必要。
      </li>
      <li>
        <m-b>自動バックアップ</m-b>: 設定した時間枠で<m-b>毎日</m-b>自動で作成するバックアップ。
        デフォルトで最新の<m-b>7</m-b>件のバックアップを保持し、 <m-b>0</m-b>~<m-b>365</m-b>件の範囲で選択できる。
      </li>
    </ul>

    <h3>Cloud SQL - メンテナンス</h3>
    <p>
      ハードウェア、OS、DBMSの更新のため、OSやDBMSの再起動が発生し、 ダウンタイムを伴う更新処理をメンテナンスを呼ぶ。
      一般的に30~120秒のダウンタイムが発生するため、
      ユーザはメンテナンスを実行する<m-b>曜日</m-b>や<m-b>時間帯</m-b>を指定することができる。 また、Cloud
      SQLでは通常数か月に一度の頻度でメンテナンスを行うが、この頻度を調整するために、
      <m-b>メンテナンス拒否期間</m-b>を指定することができる。 これは最大<m-b>90日</m-b>まで設定可能。
    </p>

    <h3>Cloud SQL - 監視とロギング</h3>
    <p>
      Cloud SQLは、<m-b>Cloud Monitoring</m-b>と<m-b>Cloud Logging</m-b>を統合し、
      データベースのパフォーマンスを監視したり、問題をトラブルシュートしたりすることができる。
      重要なメトリクスには、<m-b>CPU使用率</m-b>、<m-b>メモリ使用量</m-b>、<m-b>ストレージ使用量</m-b>、<m-b>接続数</m-b>が含まれる。
    </p>

    <h3>Cloud SQL - エディション</h3>
    <ul>
      <li><m-b>Enterprisエディション</m-b>: 従来のCloud SQLと同様のコストパフォーマンス、可用性が提供される</li>
      <li>
        <m-b>Enterpris Plusエディション</m-b>:
        <ul>
          <li><m-b>データキャッシュ</m-b>によるスループットが最大<m-b>3</m-b>倍に向上</li>
          <li>可用性<m-b>99.99</m-b>%のSLA</li>
          <li>メンテナンスによるダウンタイムが<m-b>10秒</m-b></li>
        </ul>
      </li>
    </ul>

    <h3>Cloud Spanner</h3>
    <p>
      <m-b>グローバル</m-b>かつ<m-b>無制限</m-b>にスケールが可能なフルマネージドのRDBサービス。
      単一リージョンで<m-b>99.99</m-b>%の可用性、複数リージョンで<m-b>99.999</m-b>%の可用性を実現できる。
    </p>

    <h3>Cloud Spanner - スキーマ設計のポイント</h3>
    <p>
      Cloud Spannerでは、<m-b>スプリット</m-b>という単位で、主キーの値に応じて格納されるノードが決定される。 この数は、Cloud
      Spanner側で自動で調整される<br />
      このとき、データが偏って格納されるノードを<m-b>ホットスポット</m-b>と呼ぶ。
      これを回避するには、<m-b>ランダムUUID</m-b>などの主キーを採用する必要があり、
      シーケンスなどによる連続した数は採用するべきでない。
    </p>

    <h3>AlloyDB for PostgreSQL</h3>
    <p>
      優れたパフォーマンスとスケーラビリティを備えたPostgreSQLのランタイムを提供するサービスである。 以下のような特徴がある。
    </p>
    <ul>
      <li>標準のPostgreSQLと比較して、<m-b>4</m-b>倍速くワークロードを実行</li>
      <li><m-b>HTAP</m-b>: トランザクション処理と分析処理をリアルタイムに処理するデータベースアーキテクト</li>
      <li>MLに対応した、<m-b>適応型自動パイロット</m-b>システム</li>
    </ul>

    <h3>Cloud Bigtable</h3>
    <p>
      フルマネージドな<m-b>列指向</m-b>型の<m-b>NoSQL</m-b>データベースサービスである。
      <m-b>数十億</m-b>行、<m-b>数千</m-b>列規模にスケール可能で、<m-b>ペタバイト</m-b>級のデータを扱うことができる。
      <m-b>コンピューティング</m-b>機能と<m-b>ストレージ</m-b>機能が分離しているため、
      分散したデータを高速に処理することが可能なアーキテクチャとなっている。<br />
      <m-b>SQL</m-b>を用いたクエリや<m-b>トランザクション処理</m-b>には対応していないため、注意が必要。<br />
      Apacheが提供する<m-b>HBase</m-b>というOSSと同じAPIを提供するため、 同じOSSを採用したプラットフォームからの移行が可能。
    </p>

    <h3>Cloud Bigtable - スキーマ設計のポイント</h3>
    <p>
      Cloud Spannerと同様に、<m-b>スプリット</m-b>という単位で、主キーの値に応じて格納されるノードが決定される。<br />
      このとき、データが偏って格納されるノードを<m-b>ホットスポット</m-b>と呼ぶ。
      これを回避するには、<m-b>ランダムUUID</m-b>などの主キーを採用する必要があり、
      シーケンスなどによる連続した数は採用するべきでない。<br />
      また、もう一つのアンチパターンとして、<m-b>特定の列を繰り返し更新する</m-b>というものがある。 Cloud
      Bigtableは新規データの追加に優れていて、既存データの更新性能は高くない。
      そのため、更新が頻発すると、そのノードの負荷が高まるリスクがある。
    </p>

    <h3>Firestore</h3>
    <p>
      <m-b>フルマネージド</m-b
      >、<m-b>スケーラブル</m-b>、<m-b>サーバーレス</m-b>などの特徴を持った<m-b>NoSQL</m-b>のDBサービス。
      強力なクエリエンジンを備えていて、<m-b>ベクトル検索</m-b>や<m-b>トランザクション処理</m-b>など、
      高度なクエリを実行できる。<br />
      また、<m-b>ライブ同期</m-b>と<m-b>オフラインモード</m-b>の機能を用いることで、
      エンドユーザのモバイルやIoTデバイスと連携したアプリケーション構築が可能となる。
    </p>

    <h3>Firestore - モード</h3>
    <h4><m-b>Native</m-b>モード</h4>
    <p>
      ドキュメント型のデータを扱うモード。Web・モバイルから利用しやすいライブラリが提供される。
      これにより、ブラウザ・モバイルアプリから直接アクセスが可能となる。
    </p>
    <h4><m-b>Datastore</m-b>モード</h4>
    <p>
      Key-Value型のデータを扱うモード。 大規模に構造化されたデータを扱うバックエンドアプリケーションに適していて、<m-b
        >App Engine</m-b
      >のデータベースとして利用されることが多い。従来は<m-b>Cloud Datastore</m-b>と呼ばれる独立したサービスであったが、Cloud
      Firestoreに統合された。
    </p>

    <h3>Memorystore</h3>
    <p>
      <m-b>Redis</m-b>または<m-b>Memcached</m-b>向けのフルマネージドのデータストアサービス。<br />
      上記のOSSと完全な互換性があり、移行にあたりコードの変更が不要となる。
    </p>

    <h2>ストレージ</h2>

    <h3>Cloud Storage</h3>
    <p>
      低料金で大容量のストレージサービス。
      <m-b>99.999999999</m-b>%(<m-b>イレブンナイン</m-b>)の耐久性を持つ。<br />
      <m-b>バージョニング</m-b>の機能により、削除・上書きしたオブジェクトを復元することができる。
      この機能は、<m-b>バケット</m-b>単位で設定する。 デフォルトでは<m-b>無効</m-b>である。<br />
      また、<m-b>署名付きURL</m-b>により、指定の期間内に<m-b>ダウンロード</m-b>と<m-b>アップロード</m-b>を行うための、
      URLを発行することができる。
    </p>

    <h3>Cloud Storage - バケット名の制約</h3>
    <ul>
      <li>バケット名は、<m-b>全世界</m-b>で一意の必要がある</li>
      <li>バケット作成後にバケット名は変更<m-b>できない</m-b></li>
    </ul>

    <h3>Cloud Storage - ロケーションタイプ</h3>
    <h4><m-b>リージョン</m-b></h4>
    <p>単一のリージョンにオブジェクトが保存される。データは、リージョン内の<m-b>2つ以上のゾーン</m-b>に冗長化される。</p>
    <h4><m-b>デュアルリージョン</m-b></h4>
    <p>
      地理的に近い2つのリージョンにオブジェクトが保存される。
      <m-b>南北アメリカ</m-b>、<m-b>ヨーロッパ</m-b>、<m-b>アジア太平洋</m-b>の3つの地域から選択し、
      その中で2つのリージョンを選択できる。可用性が向上する一方コストも高くなる。
      データは2つのリージョン間で、<m-b>非同期</m-b>にレプリケーションされる。
    </p>
    <h4><m-b>マルチリージョン</m-b></h4>
    <p>
      地理的に離れた2つ以上のリージョンにオブジェクトが保存される。
      <m-b>南北アメリカ</m-b>、<m-b>ヨーロッパ</m-b>、<m-b>アジア太平洋</m-b>の3つの地域から選択し、
      その中で2つのリージョンを選択できる。可用性は最も高くなる一方、ネットワークのレイテンシも高くなる場合がある。
    </p>

    <h3>Cloud Storage - ストレージクラス</h3>
    <p>
      ストレージクラスを決定するうえでは、<m-b>最小保存期間</m-b>の考慮が重要となる。
      これは、オブジェクトが一度特定のストレージクラスに保存されると、
      移動や削除を行っても定められた期間の分だけコストが発生する、という仕組みである。
    </p>
    <table>
      <thead>
        <tr>
          <th>ストレージクラス</th>
          <th>更新頻度の目安</th>
          <th>最小保存期間</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>Standard</m-b></td>
          <td>月に数回以上</td>
          <td>特になし</td>
        </tr>
        <tr>
          <td><m-b>Nearline</m-b></td>
          <td><m-b>月1回程度</m-b></td>
          <td><m-b>30日</m-b></td>
        </tr>
        <tr>
          <td><m-b>Coldline</m-b></td>
          <td><m-b>数か月に1回程度</m-b></td>
          <td><m-b>90日</m-b></td>
        </tr>
        <tr>
          <td><m-b>Archive</m-b></td>
          <td><m-b>1年に1回未満</m-b></td>
          <td><m-b>365日</m-b></td>
        </tr>
      </tbody>
    </table>

    <h3>Cloud Storage - ライフサイクル管理</h3>
    <p>
      ライフサイクル管理機能を用いると、オブジェクトの<m-b>保存期間</m-b>や<m-b>世代</m-b>に応じて、
      <m-b>コスト最適化</m-b>やデータ整理のためのアクションを自動で行うことができる。
    </p>

    <h3>Cloud Storage - アクセス制御</h3>
    <p>
      <m-b>IAM</m-b>と<m-b>ACL</m-b>を組み合わせることで、アクセス制御が可能である。
      <m-b>バケット</m-b>を作成する際に、以下の制御方法を選択できる。
    </p>
    <ul>
      <li><m-b>均一</m-b>: <m-b>IAM</m-b>のみを用いて権限を管理する。Google Cloudが推奨する。</li>
      <li>
        <m-b>きめ細かい管理</m-b>: <m-b>IAM</m-b>と<m-b>ACL</m-b>を組み合わせて管理する。<m-b>オブジェクト</m-b>毎の管理が可能。
      </li>
    </ul>

    <h3>Transfer Appliance</h3>
    <p>
      オンプレのデータを<m-b>専用ストレージ</m-b>を用いてGoogle Cloudに移行するためのプロダクト。
      <m-b>インターネット</m-b>を介さずにデータを移行するため、<m-b>高速</m-b>かつ<m-b>安全</m-b>にデータを移行できる。<br />
      以下が利用に適した条件と言える。
    </p>
    <ul>
      <li>データ量が<m-b>20TB</m-b>以上</li>
      <li><m-b>サービスが利用可能</m-b>なロケーションである</li>
      <li>インターネットを経由するとデータ移行に<m-b>1週間</m-b>以上かかる</li>
    </ul>

    <h2>ネットワーキング</h2>

    <h3>VPC - リソース構造</h3>
    <p>
      VPCネットワークは、<m-b>グローバル</m-b>なリソースとして作成される。
      VPCネットワーク自体は<m-b>IPアドレス</m-b>を持たず、1つ以上の<m-b>サブネット</m-b>を作成することで通信が可能になる。<br />
      サブネットは<m-b>リージョン</m-b>毎に作成されるリソースで、作成時に<m-b>IPアドレスの範囲</m-b>を指定する。
      同一VPC内のサブネット間は<m-b>内部IPアドレス</m-b>で通信し、外部のVPC間では<m-b>VPCネットワークピアリング</m-b>や<m-b
        >Cloud VPN</m-b
      >を用いてVPC同士を接続する。<br />
      一度設定したIPアドレスの範囲は、<m-b>拡張</m-b>することはできるが、<m-b>縮小</m-b>することはできない。
    </p>

    <h3>VPC - サブネット作成モード</h3>
    <h4><m-b>自動モード</m-b></h4>
    <p>
      各リージョンに1つずつサブネットが自動で作成されるモード。 Google
      Cloudで事前定義されたIPアドレスの範囲(<m-b>10.128.0.0/9</m-b>)が割り当てられる。 Google
      Cloudに新しいリージョンが追加されると、そのリージョンのサブネットは自動で作成される。
      新規プロジェクトには<m-b>default</m-b>という自動モードのVPCネットワークが作成される。
      これはサブネットの自動作成の他に、ネットワークをスムーズに利用するための設定が自動で行われ、
      より気軽にVPCネットワークを使用できる。
    </p>
    <h4><m-b>カスタムモード</m-b></h4>
    <p>
      ユーザが任意のリージョンにサブネットを作成できるモード。
      これにより作成したVPCネットワークでは、<m-b>IPアドレスの範囲</m-b>を完全に制御でき、
      オンプレや別のパブリッククラウドと接続するときに、IPアドレスの重複を避けることができる。<br />
      <m-b>自動</m-b>モードから<m-b>カスタム</m-b>モードへの変更はできるが、逆はできないので注意。
    </p>

    <h3>VPC - IPアドレスの種類</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>外部IPアドレス</m-b></td>
          <td>インターネットと通信可能なIPアドレス</td>
        </tr>
        <tr>
          <td><m-b>内部IPアドレス</m-b></td>
          <td>Google Cloud内でのみ通信可能なIPアドレス</td>
        </tr>
      </tbody>
    </table>

    <h3>VPC - 静的IPアドレス</h3>
    <p>
      Google Cloudのリソースに紐づくIPアドレスの多くは、
      <m-b>エフェメラルIPアドレス</m-b>というリソースの停止や削除で解放されるIPアドレスが、デフォルトで割り当てられる。
      これは、内部/外部IPアドレスで同じである。
      リソースのIPアドレスを固定する場合、<m-b>静的IPアドレス</m-b>という種類のIPアドレスを予約し、使用する必要がある。
      予約方法としては、事前に新しいIPアドレスを予約することも、既存の<m-b>エフェメラルIPアドレス</m-b>を昇格することもできる。
    </p>

    <h3>VPC - ファイアウォールのルール設定項目</h3>
    <table>
      <thead>
        <tr>
          <th>項目</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>名前</td>
          <td>ルールの名前。</td>
        </tr>
        <tr>
          <td><m-b>ログ</m-b></td>
          <td>有効/無効を設定できる。</td>
        </tr>
        <tr>
          <td><m-b>ネットワーク</m-b></td>
          <td>対象の<m-b>VPCネットワーク。</m-b></td>
        </tr>
        <tr>
          <td><m-b>優先度</m-b></td>
          <td>適用する順番を指定。<m-b>0</m-b>~<m-b>65535</m-b>まで数値を指定でき、数値が<m-b>小さい</m-b>ほど優先される。</td>
        </tr>
        <tr>
          <td>トラフィックの向き</td>
          <td><m-b>上り</m-b>/<m-b>下り</m-b>を設定できる。</td>
        </tr>
        <tr>
          <td>アクション</td>
          <td><m-b>許可</m-b>/<m-b>拒否</m-b>を設定できる。</td>
        </tr>
        <tr>
          <td><m-b>ターゲット</m-b></td>
          <td>
            ルールの適用先を選択する。 以下から選択できる。
            <ul>
              <li><m-b>ネットワーク上のすべてのインスタンス</m-b></li>
              <li><m-b>指定されたターゲットタグ</m-b></li>
              <li><m-b>指定されたサービスアカウント</m-b></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><m-b>送信元フィルタ</m-b></td>
          <td>上りルールの場合に、IPアドレス範囲を指定する。</td>
        </tr>
        <tr>
          <td><m-b>送信先フィルタ</m-b></td>
          <td>下りルールの場合に、IPアドレス範囲を指定する。</td>
        </tr>
        <tr>
          <td><m-b>プロトコル/ポート</m-b></td>
          <td>通信に関連する情報でフィルタリングの条件を指定する。</td>
        </tr>
      </tbody>
    </table>

    <h3>VPC - ファイアウォールの暗黙ルール</h3>
    <h4>下りのルール</h4>
    <p>
      下りの通信は、デフォルトですべて<m-b>許可</m-b>するルールがある。これは、最も低い優先度(<m-b>65535</m-b>)が設定されている。
    </p>
    <h4>上りのルール</h4>
    <p>
      上りの通信は、デフォルトですべて<m-b>拒否</m-b>するルールがある。これは、最も低い優先度(<m-b>65535</m-b>)が設定されている。
      一方、<m-b>default</m-b>ネットワークにはこのルールを上書きする追加ルールがあり、
      同じ<m-b>VPC</m-b>ネットワークのリソース同士の通信や、<m-b>SSH</m-b>、<m-b>RDP</m-b>、
      <m-b>ICMP</m-b>プロトコルによる通信などはデフォルトで許可される。
    </p>

    <h3>VPC - ファイアウォールポリシー</h3>
    <p>
      複数のファイアウォールルールを一つのリソースとしてグループ化して管理する機能。
      通常のファイアウォールルールは<m-b>VPC</m-b>に属するが、ファイアウォールポリシーは<m-b>組織</m-b>または
      <m-b>フォルダ</m-b>、<m-b>プロジェクト</m-b>に属する。
      そのため、複数のVPCネットワークに対し、同時にルールを適用できる。<br />
      <m-b>階層型ファイアウォールポリシー</m-b>は、下位のリソースに対してルールが継承される。
      そのため、<m-b>組織</m-b>や<m-b>フォルダ</m-b>の単位でファイアウォールルールを定義したい場合に使用する。
    </p>

    <h3>VPC - ファイアウォールポリシーの種類</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>
            定義可能な<br />
            リソース階層
          </th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td class="wrappable"><m-b>階層型ファイアウォールポリシー</m-b></td>
          <td><m-b>組織</m-b>、<m-b>フォルダ</m-b></td>
          <td>指定したリソース配下の指定の<m-b>リージョン</m-b>に対してルールを適用する。</td>
        </tr>
        <tr>
          <td class="wrappable"><m-b>グローバルネットワークファイアウォールポリシー</m-b></td>
          <td><m-b>プロジェクト</m-b></td>
          <td>指定したリソース配下の全てのVPCネットワーク内のリソースに対して適用する。</td>
        </tr>
        <tr>
          <td class="wrappable"><m-b>リージョンネットワークファイアウォールポリシー</m-b></td>
          <td><m-b>プロジェクト</m-b></td>
          <td>指定したリソース配下の全てのVPCネットワーク内、特定の<m-b>リージョン</m-b>に属するリソースに対して適用する。</td>
        </tr>
      </tbody>
    </table>

    <h3>VPC - 共有VPC</h3>
    <p>
      特定のVPCネットワークを、<m-b>組織</m-b>内の複数のプロジェクトから利用できるようにする機能。
      共有VPCを持つプロジェクトを<m-b>ホストプロジェクト</m-b>、利用するプロジェクトを<m-b>サービスプロジェクト</m-b>と呼ぶ。
      これにより、サブネットやファイアウォールの設定を各プロジェクトで行う必要がなくなり、一元的に管理できる。
      利用する側のプロジェクトが許可される操作はリソースの<m-b>作成</m-b>と<m-b>管理</m-b>のみで、
      ネットワークに影響を及ぼす操作は許可されない。
    </p>

    <h3>VPC - VPCネットワークピアリング</h3>
    <p>
      2つのVPC同士を接続する機能である。 異なる組織やプロジェクトに所属しているVPC同士を接続させることもできる。
      ピアリングされたVPC間は<m-b>内部IPアドレス</m-b>によって通信が可能なため、
      インターネットを経由しない<m-b>安全</m-b>で<m-b>高速</m-b>な通信が可能となる。<br />
      ピアリングを構成する場合、<m-b>それぞれ</m-b>のVPCで設定を行い、構成が一致する場合に有効となる。
      ただし、重複する<m-b>IPアドレス範囲</m-b>を持つVPCネットワーク同士はピアリングできないため、注意が必要。
    </p>

    <h3>VPC - 限定公開のGoogleアクセス</h3>
    <p>
      <m-b>外部IPアドレス</m-b>を持たないリソースが、GoogleのサービスやAPIにアクセスするための機能。
      この機能は、<m-b>サブネット</m-b>の単位で設定ができる。
      これにより、セキュリティ要件などでインターネットへのアクセスを避けるネットワークにおいても、
      google独自のネットワークを経由する通信が可能となる。 機能を利用する場合、料金は発生<m-b>しない</m-b>。<br />
      また、<m-b>ドメインオプション</m-b>を指定することで、アクセスするGoogleサービスのドメインを制限することができる。
      <m-b>restricted.googleapis.com</m-b>と<m-b>private.googleapis.com</m-b>を指定できる。
    </p>

    <h3>VPC - Googleサービスのドメインによるアクセス制御</h3>
    <p>
      <code>restricted.googleapis.com</code>のドメインは、<m-b>VPC Service Controls</m-b>
      がサポートするプロダクトのAPIへのアクセスを有効にする。
      これは、<m-b>サービス境界</m-b>という論理的な範囲を作成し、その範囲内に追加したAPIを保護するプロダクトである。
      <m-b>Compute Engine API</m-b>や<m-b>Cloud Storage API</m-b>などが該当する。
      このドメインを選択した場合、利用できるAPIの範囲が最も制限される。<br />
      <code>private.googleapis.com</code>のドメインは、<m-b>VPC Service Controls</m-b>のサポート有無にかかわらず、
      ほとんどのプロダクトのAPIへのアクセスを有効にできる。
    </p>

    <h3>Cloud Load Balancing</h3>
    <p>
      <m-b>グローバル</m-b>にスケーリングが可能な負荷分散を提供するプロダクト。
      背後に配置するサービスが複数の<m-b>リージョン</m-b>にまたがっていても、
      <m-b>単一のIPアドレス</m-b>を用いてリクエストを受け付け、通信の分散が可能となる。 バックエンドは、<m-b>Compute Engine</m-b
      >や<m-b>Cloud Run</m-b>のサービスなどを指定できる <m-b>バックエンドサービス</m-b>と、<m-b>Cloud Storageのバケット</m-b
      >を指定できる <m-b>バックエンドバケット</m-b>の2つから選択する。<br />
      事前に予測されるリクエスト数やデータ量を申請する必要はなく、
      アクセス数がない状態からでも<m-b>数秒</m-b>でスケーリングが可能である。
    </p>

    <h3>Cloud Load Balancing - 外部ロードバランサの種類</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>分散規模</th>
          <th>分散方式</th>
          <th>プロトコル</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td class="wrappable"><m-b>グローバル外部HTTP(S)</m-b></td>
          <td><m-b>グローバル</m-b></td>
          <td><m-b>プロキシ</m-b></td>
          <td><m-b>HTTP(S)</m-b></td>
          <td>外部からのHTTP(S)通信を複数リージョンに配置されたバックエンドに分散</td>
        </tr>
        <tr>
          <td class="wrappable"><m-b>リージョン外部HTTP(S)</m-b></td>
          <td><m-b>リージョン</m-b></td>
          <td><m-b>プロキシ</m-b></td>
          <td><m-b>HTTP(S)</m-b></td>
          <td>外部からのHTTP(S)通信を単一リージョンに配置されたバックエンドに分散</td>
        </tr>
        <tr>
          <td class="wrappable"><m-b>外部SSLプロキシ</m-b></td>
          <td>
            <m-b>グローバル/<br />リージョン</m-b>
          </td>
          <td><m-b>プロキシ</m-b></td>
          <td><m-b>SSL</m-b></td>
          <td>外部からのSSL通信をVPCネットワーク内のバックエンドへ分散</td>
        </tr>
        <tr>
          <td class="wrappable"><m-b>外部TCPプロキシ</m-b></td>
          <td>
            <m-b>グローバル/<br />リージョン</m-b>
          </td>
          <td><m-b>プロキシ</m-b></td>
          <td><m-b>TCP</m-b></td>
          <td>外部からのTCP通信をVPCネットワーク内のバックエンドへ分散</td>
        </tr>
        <tr>
          <td class="wrappable"><m-b>外部TCP/UDPネットワーク</m-b></td>
          <td><m-b>リージョン</m-b></td>
          <td><m-b>パススルー</m-b></td>
          <td>
            <m-b>TCP</m-b>、<br />
            <m-b>UDP</m-b>、<br />
            <m-b>ESP</m-b>、<br />
            <m-b>ICMP</m-b>
          </td>
          <td>外部からの通信を単一のリージョン内に配置されたバックエンドへ分散</td>
        </tr>
      </tbody>
    </table>

    <h3>Cloud Load Balancing - 内部ロードバランサの種類</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>分散規模</th>
          <th>分散方式</th>
          <th>プロトコル</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td class="wrappable"><m-b>内部HTTP(S)</m-b></td>
          <td><m-b>リージョン</m-b></td>
          <td><m-b>プロキシ</m-b></td>
          <td><m-b>HTTP(S)</m-b></td>
          <td>Google Cloud内部からのHTTP(S)通信を単一リージョン内に配置されたバックエンドへ分散</td>
        </tr>
        <tr>
          <td class="wrappable"><m-b>内部リージョンTCPプロキシ</m-b></td>
          <td><m-b>リージョン</m-b></td>
          <td><m-b>プロキシ</m-b></td>
          <td><m-b>TCP</m-b></td>
          <td>Google Cloud内部からのTCP通信を単一リージョン内に配置されたバックエンドへ分散</td>
        </tr>
        <tr>
          <td class="wrappable"><m-b>内部TCP/UDP</m-b></td>
          <td><m-b>リージョン</m-b></td>
          <td><m-b>パススルー</m-b></td>
          <td>
            <m-b>TCP</m-b>、<br />
            <m-b>UDP</m-b>
          </td>
          <td>Google Cloud内部からの通信を単一リージョン内に配置されたバックエンドへ分散</td>
        </tr>
      </tbody>
    </table>

    <h3>Cloud CDN</h3>
    <p>
      高速なコンテンツ配信を実現するプロダクト。
      Google独自のネットワークを用いて、<m-b>リクエスト元</m-b>ユーザからできるだけ近いロケーションにコンテンツをキャッシュできる。
      このサービスは、<m-b>グローバル外部HTTP(S)ロードバランサ</m-b>と連携して利用する。
      料金は、<m-b>キャッシュするデータ量</m-b>、<m-b>キャッシュから取り出されたデータ量</m-b>、
      <m-b>キャッシュ検索リクエスト数</m-b>に応じて発生する。
    </p>

    <h3>Cloud DNS</h3>
    <p>
      Googleネットワークにより提供される、低遅延で可用性が高いDNSを提供するサービス。
      <m-b>マネージドゾーン</m-b>と呼ばれる論理コンテナを用いてDNSレコードを管理する。
      <m-b>1つ</m-b>のプロジェクトに<m-b>複数</m-b>の論理コンテナを作成できるが、プロジェクト内で一意な名前を付ける必要がある。
    </p>

    <h3>Cloud DNS - マネージドゾーンの種別</h3>
    <h4><m-b>一般公開ゾーン</m-b></h4>
    <p>インターネットに公開されるゾーン。</p>
    <h4><m-b>限定公開ゾーン</m-b></h4>
    <p>
      インターネットに公開されず、VPCネットワーク内からのみアクセスできるゾーン。
      <m-b>VPCリンク機能</m-b>によってアクセス可能なVPCを指定できる
    </p>

    <h3>Cloud NAT</h3>
    <p>
      フルマネージドにNATを提供するサービス。 Cloud
      NATを使用することで、ComputeEngineインスタンス等に外部IPアドレスを割り当てずとも、インターネットとの通信が可能となる。
      Cloud NATで使用される外部IPアドレスは、デフォルトで<m-b>自動</m-b>に割り当てられるが、ユーザが指定することもできる。
      また、外部IPアドレスの数は自動的に<m-b>スケーリング</m-b>させることができる。<br />
      料金は、Cloud NATに割り当てられる<m-b>リソースの数</m-b>に応じて発生する。
      割り当て数が一定数を超えると、料金は一定となる。
    </p>

    <h3>Cloud VPN</h3>
    <p>
      オンプレや別のクラウドとVPCネットワークをセキュアに接続するプロダクト。
      <m-b>IPsec</m-b>というプロトコルを使用する。<br />
      クラウド側のコンポーネントを<m-b>Cloud VPN Gateway</m-b>、オンプレ側のコンポーネントを<m-b>VPN Gateway</m-b
      >と言ったりする。 また、この通信路を<m-b>VPNトンネル</m-b>という。
      料金は、アクティブな<m-b>VPNトンネル</m-b>毎に時間単位で発生する。<br />
      帯域幅は1トンネル当たり最大<m-b>3Gbps</m-b>である。
    </p>

    <h3>Cloud VPN - タイプ</h3>
    <p>Cloud VPNには次の2種類のCloud VPN Gatewayがある。</p>
    <ol>
      <li>
        <b><m-b>HA VPN</m-b></b
        ><br />
        高可用性ソリューションで、<m-b>99.99%</m-b>の可用性を提供する。<br />
        <m-b>2</m-b>つのVPNトンネルを用いて冗長構成をとり、<m-b>2</m-b>つのIPアドレスが動的に構成される。
      </li>
      <li>
        <b><m-b>Classic VPN</m-b></b
        ><br />
        1.の導入前に作成されたゲートウェイ。1つのIPアドレスが静的に構成される。
      </li>
    </ol>

    <h3>Cloud Interconnect</h3>
    <p>
      高可用性で低レイテンシな接続で、オンプレや別のクラウドとVPCネットワークを構築するサービス。
      <m-b>内部IPアドレス</m-b>を構成し通信する。 <m-b>インターネット</m-b>を経由しないため、よりセキュアな通信を実現できる。
    </p>

    <h3>Cloud Interconnect - オプション</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>帯域幅</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>Dedicated Interconnect</m-b></td>
          <td><m-b>10Gbps</m-b>~<m-b>100Gbps</m-b></td>
          <td>オンプレとGoogleネットワークを専用線によって直接接続</td>
        </tr>
        <tr>
          <td><m-b>Partner Interconnect</m-b></td>
          <td><m-b>50Mbps</m-b>~ <m-b>50Gbps</m-b></td>
          <td>オンプレのネットワークをサービスプロバイダを介してGoogleネットワークに直接接続</td>
        </tr>
      </tbody>
    </table>

    <h3>Cloud Armor</h3>
    <p>
      DDoS、XSS、SQLインジェクションといった攻撃からデプロイを保護するソリューション。
      <m-b>自動保護</m-b>と<m-b>手動構成</m-b>の機能がある。
    </p>

    <h3>Cloud Armor - セキュリティポリシー</h3>
    <p>
      セキュリティポリシーを用いることで、Google Cloud、ハイブリッド、マルチクラウドのアーキテクチャを問わず、
      アプリケーションを保護する。
      <m-b>許可</m-b>または<m-b>拒否</m-b>ルールの集合として扱われる。<br />
      <m-b>一致条件</m-b>と<m-b>アクション</m-b>を使用して、手動で構成することが可能。
      また、様々なユースケースに対応した<m-b>事前定義</m-b>されたセキュリティポリシーもある。<br />
      セキュリティポリシーのルールは、<m-b>Match条件</m-b>と呼ばれる条件を、<m-b>ルール言語</m-b>を用いて記述する。
      <m-b>IPアドレス</m-b>、<m-b>HTTPヘッダ</m-b>、<m-b>URLパス</m-b>、<m-b>クエリパラメータ</m-b>
      などの属性に基づいてルールを定義できる。
    </p>

    <h2>インテグレーション</h2>

    <h3>Pub/Sub</h3>

    <h3>Cloud Tasks</h3>

    <h3>Cloud Scheduler</h3>

    <h3>Cloud Composer</h3>

    <h3>Apigee API</h3>

    <h3>Artifact Registry</h3>

    <h2>アクセス管理</h2>

    <h3>Cloud IAM</h3>
    <h4>主な構成要素</h4>
    <ul>
      <li>
        <m-b>アイデンティティ</m-b>(<m-b>プリンシパル</m-b>): 権限を付与する対象
        (<m-b>ユーザ</m-b>、<m-b>グループ</m-b>、<m-b>サービスアカウント</m-b>など)
      </li>
      <li><m-b>リソース</m-b>: 権限のアクセス対象</li>
      <li><m-b>ポリシー</m-b>: 「誰が何に対して権限を持つか」</li>
      <li><m-b>権限</m-b>: リソースに対する具体的な操作を定義</li>
      <li><m-b>役割</m-b>: <m-b>権限</m-b>の集合</li>
    </ul>
    <p>
      <m-b>アイデンティティ</m-b>に<m-b>権限</m-b>を直接付与することはできない。
      <m-b>役割</m-b>に<m-b>権限</m-b>を紐づけ、<m-b>ポリシー</m-b>を用いて<m-b>アイデンティティ</m-b>に付与する。
    </p>

    <h3>Cloud Identity</h3>
    <p>
      <m-b>Google Warkspace</m-b>を使用していない場合に、企業などでユーザ管理を行う場合のプロダクト。 Google
      Cloudを企業で利用する場合、個人が所有するGoogleアカウントを使用するのではなく、 ユーザを一元管理できるCloud
      Identityの使用が推奨される。Cloud Identityへの登録には、企業が所有する<m-b>インターネットドメイン</m-b>が必要となり、
      これによりCloud Identityと<m-b>組織リソース</m-b>を紐づけることができる。<m-b>組織リソース</m-b>は、Cloud
      Identityの設定が完了されると自動で作成される。
    </p>

    <h3>Cloud Identity - ADとの連携</h3>
    <p>
      Cloud Identityは、Active Directoryなどの外部認証システムと、ユーザやグループを同期させることができる。このとき、<m-b
        >Google Cloud Directory Sync</m-b
      >というツールを使用して、同期を行う。この同期処理は、ADとCloud Identityの間で<m-b>1方向</m-b>となる。
      また、AD側の<m-b>ADフェデレーションサービス</m-b>により、<m-b>SSO</m-b>が実現できる。
    </p>

    <h3>VPC Service Controls</h3>
    <p>
      Google Cloudのセキュリティ機能の一つ。
      <m-b>サービス境界</m-b>と呼ばれる論理的な囲いを作り、セキュリティを確保する。 以下のようなことを実現できる。
    </p>
    <ul>
      <li><m-b>BigQuery</m-b>に対するクエリの発行元を制限</li>
      <li><m-b>Cloud Storage</m-b>からのオブジェクト読み取りのアクセス元を制限</li>
      <li><m-b>GKE</m-b>クラスターの設定変更のアクセス元を制限</li>
    </ul>

    <h3>VPC Service Controls - サービス境界の設定</h3>
    <ul>
      <li><m-b>外向き</m-b>と<m-b>内向き</m-b>のルールをそれぞれ設定できる</li>
      <li>
        以下の情報からリクエスト元を判別することができる。
        <ul>
          <li><m-b>IPアドレスの範囲</m-b></li>
          <li><m-b>デバイス情報</m-b></li>
          <li><m-b>地理的情報</m-b></li>
          <li><m-b>GoogleCloudプロジェクト</m-b></li>
          <li><m-b>VPCネットワーク</m-b></li>
        </ul>
      </li>
    </ul>

    <h3>Identity-Aware Proxy</h3>
    <ul>
      <li>
        <m-b>クラウドベース</m-b>または<m-b>オンプレ</m-b>のアプリケーション、
        <m-b>Google Cloud</m-b>上で稼働するVMへのアクセス制御を行う。
      </li>
      <li><m-b>ユーザID</m-b>を確認し、コンテキストでユーザアクセスを管理する。</li>
      <li><m-b>VPN</m-b>を使用せずとも、ネットワークレベルでアクセス制御を行うことができる。</li>
      <li><m-b>ゼロトラスト</m-b>のアクセスモデルを提供する。</li>
      <li>
        <m-b>TCP転送</m-b>により、Google CloudでホストされるVMへの
        <m-b>SSH</m-b>及び<m-b>RDP</m-b>によるアクセスを保護することも可能。
        VMインスタンスに<m-b>パブリックIPアドレス</m-b>の割り当てが不要となる。
      </li>
    </ul>

    <h3>Access Approval</h3>
    <p>
      Google
      Cloudの従業員がユーザ環境へアクセスすることは基本的にないが、トラブルシューティングなどのサポートでアクセスが必要なケースがある。
      このとき、Access Approvalという仕組みでGoogleサポートチームのアクセスリクエストを承認する。
      これを承認するには、組織内のプリンシパルに<m-b>アクセス承認者</m-b>という事前定義ロールを付与しておく必要がある。
      また、アクセスリクエストは<m-b>メール</m-b>または<m-b>Pub/Sub</m-b>メッセージで受け取ることができる。
    </p>

    <h2>セキュリティ</h2>

    <h3>Secret Manager</h3>
    <p>
      <m-b>APIキー</m-b>、<m-b>パスワード</m-b>、<m-b>証明書</m-b>、その他<m-b>センシティブデータ</m-b>
      を保存するためのストレージシステム。 Google
      Cloudで使用するすべてのシークレットを一元的に管理、アクセス、監査することが可能な、 信頼できる唯一の情報源である。
    </p>

    <h3>Secret Manager - 特徴</h3>
    <h4><m-b>最小権限</m-b>の容易な実装</h4>
    <p>
      <m-b>Cloud IAM</m-b>の<m-b>役割</m-b>を使用して実現できる。
      シークレットへのアクセスを個別に付与し、管理とアクセスの機能を分離することができる。
    </p>
    <h4><m-b>ライフサイクル</m-b>管理が簡単になる</h4>
    <p>
      <m-b>バージョニング</m-b>機能があり、<m-b>Cloud Functions</m-b>を使用してローテーションも可能。
      バージョンは固定の数や、「latest」のような<m-b>エイリアス</m-b>を使用することができる。
    </p>
    <h4>高度な<m-b>監査</m-b></h4>
    <p>
      <m-b>Cloud Audit Logs</m-b>と統合されているため、全ての操作が監査ログに記録される。
      これにより、監査要件やコンプライアンス要件を容易に満たす。
    </p>
    <h4><m-b>レプリケーション</m-b>のポリシー</h4>
    <p>
      Secret Managerは<m-b>グローバル</m-b>なリソースであるが、データはリージョンに保存される。
      このリージョンは指定することも、自動で決定することも可能である。
      いずれの場合も、データの<m-b>レプリケーション</m-b>は自動で行われる。
    </p>
    <h4>暗号化</h4>
    <p>転送は<m-b>TLS</m-b>で暗号化され、保存は<m-b>AES 256bit 暗号鍵</m-b>で暗号化される。</p>
    <h4>ハイブリット環境のサポート</h4>
    <p>
      <m-b>VPC Service Controls</m-b>を使用することで、ハイブリット環境の<m-b>コンテキスト・アウェア・アクセス</m-b>
      を実現することが可能。
    </p>

    <h3>Cloud Key Management</h3>

    <h3>Security Command Center</h3>

    <h3>BeyondCorpモデル</h3>
    <p><m-b>Google</m-b>が提唱する<m-b>ゼロトラスト</m-b>のセキュリティモデル。 以下の機能を持つ。</p>
    <ul>
      <li><m-b>SSO</m-b>: 認証を容易にする</li>
      <li>
        リアルタイムでのきめ細やかなアクセス制御: コンテキスト情報 (<m-b>アクセス場所</m-b>や<m-b>デバイス</m-b>など)
        を参照してアクセス制御を行う
      </li>
      <li><m-b>多要素認証</m-b>: より強固な認証機能を提供する</li>
    </ul>

    <h2>運用オペレーション</h2>

    <h3>請求先アカウント</h3>
    <p>
      Google Cloudではプロジェクトで発生する料金を支払うために、
      <m-b>プロジェクト作成</m-b>時にCloud請求先アカウントと紐づける必要がある。
      請求先アカウントは通常のユーザとは性質が異なり、支払いに関する設定を管理するリソースである。
      1つの請求先アカウントには<m-b>複数</m-b>のプロジェクトを紐づけることができる。 無料枠を用いてGoogle
      Cloudプロジェクトを利用する場合、請求先アカウントの紐づけは<m-b>必要</m-b>である。
    </p>

    <h3>請求先アカウント - 請求先アカウントに関する事前定義ロール</h3>
    <table>
      <thead>
        <tr>
          <th>ロール名</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>請求先アカウント作成者</m-b></td>
          <td>アカウントの新規作成が可能</td>
        </tr>
        <tr>
          <td><m-b>請求先アカウント管理者</m-b></td>
          <td>
            アカウントとの紐づけ解除や、アカウント関連のロールの割り当てなど、管理操作が可能。
            アカウントの新規作成は<m-b>できない</m-b>ことに注意。
          </td>
        </tr>
        <tr>
          <td><m-b>請求先アカウントの費用管理者</m-b></td>
          <td>予算設定や費用情報の閲覧、エクスポートが可能</td>
        </tr>
        <tr>
          <td><m-b>請求先アカウント閲覧者</m-b></td>
          <td>費用情報の閲覧が可能</td>
        </tr>
        <tr>
          <td><m-b>請求先アカウントユーザ</m-b></td>
          <td>アカウントの紐づけが可能。<m-b>紐づけ解除</m-b>はできないことに注意。</td>
        </tr>
        <tr>
          <td><m-b>プロジェクト支払い管理者</m-b></td>
          <td>アカウントの紐づけと紐づけ解除が可能</td>
        </tr>
      </tbody>
    </table>

    <h3>コスト管理 - コスト見積</h3>
    <p>
      <m-b>Google Cloud Pricing Calculator</m-b>を用いると、発生する費用を事前に計算することができる。
      リソースを配置する<m-b>リージョン</m-b>や通信料、データ量などを入力して使用する。
    </p>

    <h3>コスト管理 - 予算アラート</h3>
    <p>
      請求先アカウントに対する予算設定と、超過した場合の通知機能を提供するサービス。
      通知の閾値を任意に設定することができ、<m-b>メール</m-b>による通知や、<m-b>Pub/Sub</m-b>にメッセージを送信することができる。
      ただし、アラート通知が発生しても、自動的にリソースが停止するわけではないことに注意する。
      デフォルトで、<m-b>請求先アカウント管理者</m-b>と<m-b>請求先アカウントユーザ</m-b>のロールを持つユーザが受信できるようになっている。
      <m-b>Cloud Monitoring</m-b
      >で<m-b>アラートポリシー</m-b>を設定することで、組織内の任意のユーザに対して予算アラートを通知することも可能。
    </p>

    <h3>コスト管理 - 請求レポート</h3>
    <p>
      Google Cloudの課金情報は、請求レポートとして<m-b>コンソール</m-b>から確認ができる。
      <m-b>費用履歴</m-b>や<m-b>費用の傾向</m-b>、<m-b>費用の予測</m-b>などを視覚的に確認できる。
    </p>

    <h3>コスト管理 - 課金データのエクスポート</h3>
    <p>
      課金データは<m-b>BigQuery</m-b>や<m-b>Cloud Storage</m-b>にエクスポートすることができる。
      <m-b>BigQuery</m-b>にエクスポートした場合、SQLクエリを用いた分析や今後の予測ができ、
      <m-b>請求レポート</m-b>よりも詳細な分析が可能となる。
      課金データのエクスポートは<m-b>任意</m-b>のタイミングで有効化できるが、
      <m-b>過去のデータ</m-b>を反映させることはできないため、請求先アカウントの作成時に有効化することが推奨される。
    </p>

    <h3>Cloud Audit Logs</h3>
    <p>
      監査ログを記録、閲覧するサービス。
      <m-b>リソースの作成</m-b>や<m-b>データの読み書き</m-b>などの操作が、ログとして記録される。
      これにより、不正アクセスやデータ漏洩の有無を監査できる。
    </p>

    <h3>Cloud Audit Logs - 監査ログの種類</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>デフォルト<br />設定</th>
          <th class="wrappable">設定変更<br />可否</th>
          <th>料金</th>
          <th>説明</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>管理アクティビティ監査ログ</m-b></td>
          <td><m-b>有効</m-b></td>
          <td><m-b>不可</m-b></td>
          <td><m-b>無料</m-b></td>
          <td>リソース構成やメタデータの更新に関するログ</td>
        </tr>
        <tr>
          <td><m-b>データアクセス監査ログ</m-b></td>
          <td>
            <m-b>無効</m-b><br />
            ※<m-b>BigQuery</m-b>のみ<m-b>有効</m-b>
          </td>
          <td><m-b>可</m-b></td>
          <td><m-b>有料</m-b></td>
          <td>
            リソース構成やメタデータの読み取り、及びユーザが実行した操作に関するログ。
            有効化することが推奨されるが、データ量が膨大化することに注意が必要。
          </td>
        </tr>
        <tr>
          <td><m-b>システムイベント監査ログ</m-b></td>
          <td><m-b>有効</m-b></td>
          <td><m-b>不可</m-b></td>
          <td><m-b>無料</m-b></td>
          <td>Google Cloud側で実行された操作に関するログ</td>
        </tr>
        <tr>
          <td><m-b>ポリシー拒否監査ログ</m-b></td>
          <td><m-b>有効</m-b></td>
          <td><m-b>不可</m-b></td>
          <td><m-b>有料</m-b></td>
          <td>
            セキュリティポリシー違反によるログ。
            <m-b>VPC Service Controls</m-b>によって定義されるルールによって決められる。
            保存対象のログを<m-b>フィルタリング</m-b>できる。
          </td>
        </tr>
      </tbody>
    </table>

    <h3>Cloud Audit Logs - ログの保管について</h3>
    <p>
      監査ログは、<m-b>Cloud Logging</m-b>によって保管され、<m-b>ログバケット</m-b>という場所で保管される。
      これは次の2種類がある。
    </p>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>保管対象</th>
          <th>デフォルト<br />保存期間</th>
          <th>設定変更<br />可否</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>_Required</m-b></td>
          <td>
            <ul>
              <li><m-b>管理アクティビティ監査ログ</m-b></li>
              <li><m-b>システムイベント監査ログ</m-b></li>
            </ul>
          </td>
          <td><m-b>400日</m-b></td>
          <td><m-b>不可</m-b></td>
        </tr>
        <tr>
          <td><m-b>_Default</m-b></td>
          <td>
            <ul>
              <li><m-b>データアクセス監査ログ</m-b></li>
              <li><m-b>ポリシー拒否監査ログ</m-b></li>
            </ul>
          </td>
          <td><m-b>30日</m-b></td>
          <td><m-b>可</m-b></td>
        </tr>
      </tbody>
    </table>

    <h3>Cloud Audit Logs - ログバケットの設定変更について</h3>
    <p>
      <m-b>_Default</m-b>ログバケットは、ログの保存期間を<m-b>1日</m-b>~<m-b>3650日</m-b>の範囲で設定変更できる。
      保存期間を長く設定するほど、管理するログサイズが増え<m-b>料金</m-b>が増えることに注意する。
      また、ユーザ定義のログバケットを作成することもでき、その場合のログ保存期間は<m-b>1日</m-b>~<m-b>3650日</m-b>の範囲で設定変更できる。
    </p>

    <h3>Cloud Audit Logs - ログの転送</h3>
    <p>
      Cloud Audit Logsでは、<m-b>シンク</m-b>と呼ばれる機能を用いることで監査ログを他の場所へ転送できる。 転送先としては、<m-b
        >Cloud Storage</m-b
      >、<m-b>BigQuery</m-b>、<m-b>Pub/Sub</m-b>、<m-b>ユーザ定義のログバケット</m-b>を指定できる。
      管理方法によっては、ログを保持するコストを削減することができる。
      また、組織レベルで<m-b>集約シンク</m-b>と呼ばれる機能を使用することで、組織配下のプロジェクトにおける監査ログを1か所に集約することができる。
    </p>

    <h3>Cloud Audit Logs - 監査ログへのアクセス制御</h3>
    <p>
      監査ログへのアクセス制御には、<m-b>IAM</m-b>を用いることができる。
      事前定義ロールとして<m-b>プライベートログ閲覧者</m-b>があり、これを付与すると<m-b>_Default</m-b>ログバケット内の<m-b>データアクセス監査ログ</m-b>を閲覧できる。
      また、<m-b>Cloud Logging</m-b>関連のロールや権限を用いることで、詳細なアクセス制御が可能となる。
    </p>

    <h3>Cloud Monitoring</h3>

    <h3>Cloud Logging</h3>
    <p>
      ログの<m-b>表示</m-b>、<m-b>保管</m-b>、<m-b>検索</m-b>、<m-b>分析</m-b>などの機能を提供するログ管理システム。 Google
      Cloudリソース作成、削除のログや、Google
      Cloud、他のパブリッククラウド、オンプレ上で構築したアプリケーションのログも収集できる。<br />
      収集されたログは、まず<m-b>ログルータ</m-b>と呼ばれるリソースに受け渡される。
      そこで<m-b>シンク</m-b>というルールを設定することで、指定された宛先にログを転送する。
      デフォルトで、<m-b>組織</m-b>、<m-b>フォルダ</m-b>、<m-b>プロジェクト</m-b>毎に作成される、
      <m-b>_Required</m-b>、<m-b>_Default</m-b>という<m-b>ログバケット</m-b>が、宛先に設定されている。<br />
      宛先にはCloud Loggingのログストレージ以外にも、<m-b>Cloud Storage</m-b
      >、<m-b>BigQuery</m-b>、<m-b>Pub/Sub</m-b>を指定することができる。
    </p>

    <h3>Cloud Logging - 操作</h3>
    <table>
      <thead>
        <tr>
          <th>種類</th>
          <th>クエリ言語</th>
          <th>ユースケース</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><m-b>ログエクスプローラ</m-b></td>
          <td><m-b>Cloud Logging用のクエリ言語</m-b></td>
          <td>
            <ul>
              <li>アプリのトラブルシューティング</li>
              <li>パフォーマンス分析</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><m-b>Log Analytics</m-b></td>
          <td><m-b>SQL</m-b></td>
          <td>
            <ul>
              <li>ログの集計・分析</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>

    <h3>Cloud Logging - ログの収集手段</h3>
    <h4>Compute Engineインスタンス</h4>
    <p>
      <m-b>Opsエージェント</m-b>というエージェントをインスタンスにインストールし、標準のシステムログを収集する。
      具体的には、Linuxの場合<m-b>/var/log/syslog</m-b>や<m-b>/var/log/messages</m-b>、Windowsの場合<m-b>イベントログ</m-b>を取得する。
    </p>
    <h4>GKEクラス</h4>
    <p>
      <m-b>Cloud Operations for GKE</m-b>という機能が、GKEクラスタの機能として提供されている。
      これはクラスタの<m-b>作成時</m-b>にデフォルトでCloud Loggingとの統合を有効にするもので、
      クラスタに関するどのログを転送するか制御できる。
    </p>

    <h3>Cloud Trace</h3>
    <p>
      アプリケーションがリクエストを処理する時間を測定するトレース機能を提供するプロダクト。 Cloud
      Traceでトレース情報を測定するには、<m-b>アプリケーションのコード</m-b>を構成する必要がある。
      レイテンシ軽減のための<m-b>パフォーマンス分析情報</m-b>も確認できるため、改善につなげることができる。<br />
      トレースデータの送信にはライブラリやAPIなどいくつか方法があるが、<m-b>OpenTelemetry</m-b>の使用が推奨されている。
      これは、分散されたアプリケーションにおけるトレースデータの収集に適したオープンソースツールである。
    </p>

    <h3>Cloud Profiler</h3>
    <p>
      <m-b>本番環境</m-b>でのアプリケーションのパフォーマンス情報を継続的にプロファイルするためのプロダクト。
      これにより、アプリケーションが使用する<m-b>CPU</m-b>や<m-b>メモリ</m-b>などのリソース状況を確認することができる。
      また、Cloud Profilerは低負荷のため、パフォーマンスに影響をほとんど与えない。
    </p>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/dexie/4.0.8/dexie.min.js"
      integrity="sha512-Yp2Q03YGorJ+zy5dF6XnTwmtW9MOnJwCG15PH50C5FZcw9TaUHP3ZeSNNkkpjMUD6gOCGyWTLJRkTNjrik9oDA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script
      src="https://code.jquery.com/jquery-3.7.1.min.js"
      integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
      crossorigin="anonymous"
    ></script>
    <script src="./asset/script.js"></script>
  </body>
</html>
